.. Copyright (C) ALbert Mietus; 2020, 2023

.. sidebar:: On this page
   :class: localtoc

   .. contents::
      :depth: 3
      :local:
      :backlinks: none

.. _startingBTDD:

**************************
Applying BDD & TDD (DRAFT)
**************************

.. post:: 2023/05/07
   :tags: BDD, TDD, Modernize
   :category: opinion
   :location: Geldrop
   :language: en

   :reading-time: XXX

   As I described last week (in :ref:`introducingBTDD`), understanding the common goals of Behavior & Test Driven
   Development **and** defining your specific needs is the first and most critical step to start using this essential
   discipline.
   |BR|
   Whenever the goal is to use new tools, it is simple: purchase them, shop for some hands-on training, and you are
   done.

   Our ambition is different: we want to become *Agile* and *Lean*.
   |BR|
   Then, it depends on the starting point too. B&TDD in greenfield development is relatively simple: start writing your
   tests and code!

   However, starting with B&DD in (Modern) Embedded Software can be more challenging due to the existing and often
   extensive codebase that was developed before the emergence of B&DD.
   |BR|
   Then, the question ‘How to start?’ is more like *’How to get out of the waterfall?’*


=============
How to start?
=============

With millions of lines of existing code, a requirement such as ‘*Apply TDD (or/or BDD) everywhere*’ isn’t realistic.
One needs realistic goals, both as points on the horizon and for the short term.  And one should constantly measure
whether you have reached them.
|BR|
Sound familiar? That is essentially TDD!

A requirement like: ‘*For every iteration (sprint, release, ...), the test coverage should grow*’ is more realistic. And is
relatively easy to measure.
|BR|
I like to extend that requirement, in two ways:

#. Such that is valid for all levels in the ‘V’, so for all units (unit tests), modules, and the system (acceptance
   tests)
#. That only automated tests count.

.. tip::

   I deliberately demand *more* coverage only, not that *new code* is developed with Behavior or Test Driven
   Development.
   |BR|
   That is the easiest implementation, and so I expect that. But when *old code* is improved that is acceptable too --even
   when that comes with new “untested” code.

   It’s unlikely that somebody, or a team does so,  --and stupid. But by defining the requirement in this way, it’s a
   lot easier to count.
   |BR|
   And measuring is even more important.

Add the measurements
====================

Many definitions  (and tools) exist on “how to count coverage”.  For a start, the exact measurement is not that
important. For now, a simple, quick (and simple) visualisation is more important than anything else.

With a good toolsmith in the team, I would go for something simple as ‘grep & count’ functions in test and
production code and show the quotient (over time). Someday, that number should be (far) above 1.0. Probably, you will
start close to 0.0.
|BR|
That number should be calculated per file (roughly unit-level), per directory (module level), and aggregated up to
system level. For that level, you probably like to count acceptance, not technical tests. When available, you can 
also display the ratio number-of-acceptance-tests to the number-of-requirements.

Because it is simple, developers can influence it and are motivated to add more tests.
|BR|
That is the goal, so even when the counting tool is only an approximation, it will do.

Clean Code is short-code
------------------------

New functions should be implemented in a “clean style” so testable code. Which suggests small functions.

Therefore I would also like to add a simple measurement as the “line-count pro function”. And visualize that in buckets: the
percentage of functions that are less (or equal to) 5 lines, 10, 24, 63 lines, etc. Over time the smaller buckets should
be dominant.

---

* TDD is a discipline that each individual developer can do. And one can make a start of new code at any time.

* No fancy tools are essential. One can start with the discipline that all new code should be testable, and tests should
  be written first.

Introducing TDD in an existing project is never perfect. Temporally, one should accept that existing/old code will have
no or very limited test coverage. Some ancient-styled, never-updated code will effectively never becomes better -- on
the other hand, when there is no need to update it, and it is *field proven correct*, there is no business value in
making it better.


*   Measure TDD by counting & tracking the part of the code that has coverage
        


===============
Where To start?
===============

Developer versus Team
=====================

TDD and BDD act on different levels. TDD is typically at the bottom of the *’V’*; BDD is more at the system (or
acceptance) level.
|BR|
However, that is often confusing for new adopters.

Therefore I often use a more pragmatic distinguishment: Individual Developer versus (scrum)Team.
|BR|
A single developer can act following  TDD. (S)he writes code, tests, and production code and switches between them
every minute. As TDD is more productive, hardly anyone will notice it when somebody “secretly” adopts TDD. No
extra tools or frameworks are essential.

That is hardly possible with BDD, as this is at the team level. A developer can’t run an acceptance test without the
assistance of a tester designer.
|BR|
Despite this, a single team can embrace BDD -- even when others don’t

This is valid for all levels: the larger the part that is worked on, the more commitment needs to be able to run those
ATSes.


1. Product-quality improvement: in short: better code and better products

   - TDD focuses more on the *abilities* of code: readability, testability, **maintainability**, etc.
   - BDD is more product-level: **“Does it do what is specified?”**, and “Are the specification correct?”

2. Process optimisation: reduce the cost of the development cycle.

   - The faster a bug is signaled, the cheaper is to repair.
   - TDD also provides an *‘exit strategy’*; an often forgotten “side-effect” increasing velocity.

------------

With a goal as described above: one has to discipline the team. And **unlearn** old habits as spend-up the ‘left
time’. That is a lot harder, as nobody is wasting time! (Remember: *improving ‘abilities’ is worthwhile*, and a TDD
goal!)

As BDD is a variant of TDD and has a bigger (organisational) scope, it is often easier to start with TDD. This can be
done on unit/file, and/or module level, by one individual software-developer, or by a single (scrum) team.

TDD on TDD
==========


Let’s start with a test, as TDD describes. But now on the process improvement itself.  Now we have set the goals, its
easy to transform them into tests. Or, possibly a timeline of intermediates goals. Each goal needs some tests. Probably
not as exact as we like with typical *ATSes*, but ar least clear and “SMART”.

As you have your own goals, you need your distinct test-set. But assume you would like to improve both on quality and
productivity. Then a simple testable goal is the number of issues found “after” the sprint ends.  When this becomes zero
your quality-goal is met.
|BR|
And the velocity-increment is a great measure for productivity growth.

I would introduce some simple transitional goals too. Like, the number of flaws the QA-department finds should go down
*every* iteration. And *each* sprint the number of unfinished features should lower first, and the number of fully
correct features should fo up, secondly.

This sounds simple. And it is, except for the first time!
|BR|
Having a (quite) objective test does help, but the hard work is to improve yourself. To get comfortable with the new,
initially counter-intuitive routines will take practice and time.

But at least you have a great start!

Training & Mentoring
====================

Engineers are awesome in problem-solving. And although a quest like “start with TDD” is nebulous, when transformed into a
problem they like to fix it.  Especially when you give them some assistance and a sound target like passing a test.
|BR|
With the ‘TDD on TDD’ trick, you are ready to finish.

There are many books & and videos on TTD. They can help to start. As a downer, they focus often on classical ICT, not
high-tech, embedded product development. And so, they often don’t inspire.
|BR|
Also, many books are on ‘*How’* to do TDD, on using a tool.

Engineers like to understand ‘**WHY**’. Then, the can deal with the issue.

Uncle Bob
---------
Uncle Bob has several videos on TDD and BDD. See :ref:`BTDD_UncleBobList` for an overview. Start with the basic TDD (6.*)
ones! They explain the ‘Why’.

.. hint::

   Most examples are in Java, and not very technical. This is fine for a start. Still, I would love an ‘add-on’ on the
   typical high-tech, embedded, product-development aspects; but that is not available.


Intervision & coaching
----------------------

A very effective, lean, and iterative concept I practice is *Video-of the week*.
|BR|

A group of people watches that selected video and at the end of the week, we speak about it for an hour and a half;
shared in the pre-corona era. Now it’s on-line, both work fine.

By having a group of mixed experiences, backgrounds, and ages, that *debriefing* becomes very encouraging and brings a huge
value.

.. tip::

   When you like to start with TDD or BDD or when you think about it, but don’t know ‘why’, or ‘how to start’: Give me a
   call. I will gladly boost your product and team.


--- :SwBMnl-email:`Albert.Mietus`



..  LocalWords:  distinguishment

----

The practice implementation to create ATS for the various levels may depart. This will depend on the size of the
product, so on ‘the depth of the V’; on the background & environment of the teams; on their (technical) capability; etc.
One may see other tools, other skills, and often other people that become responsible.

Some like to introduce new, or more terms for each level or implementation detail. I prefer to use the term TDD
generically, as the process is equivalent.
|BR|
Remember: changing it in name only, does not improve the process. As long as you reach your goals, I can live with
any name.
